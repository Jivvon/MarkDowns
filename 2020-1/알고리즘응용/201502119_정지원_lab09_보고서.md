# 201502119 정지원 lab09 보고서

#### 초기값

```python
LETTERS = 5 # 글자 수 (여기서는 데이터의 한 row의 수)
WORDS = 10 # 단어 수 (여기서는 반복 수)
INITNUM = 1.0 # 초기 점수
```

5x1의 데이터가 10번 반복될 것이다.

#### decoder

greedy decoder와 beam decoder를 구현할 것이다.

- 각각의 데이터는 한번에 넣어주지 않고, 매 반복마다 random의 seed를 점수로 설정하여 다른 값이 적용되도록 한다.
- 점수는 랜덤한 숫자 중 낮은 숫자를 높은 점수로 하여 계산한다.
- 0~1 사이의 랜덤한 값이 나오기 때문에 쉽게 다루기 위해 점수에 10을 곱해준다.
- 숫자의 값이 작을수록 큰 점수가 나오도록 -log를 취해준다.

##### greedy decoder

```python
def greedy_decoder():
    ret = [[], INITNUM] # [[점수에 적용된 인덱스 순서], 점수]
    for _ in range(WORDS):
        score = ret[1] * 10
        np.random.seed(int(score)) # random seed를 score로 한 후
        row = np.random.rand(LETTERS) # random data를 생성하여
        idx = np.argmax(row) # 보기 중에 가장 큰 값의 인덱스
        ret[0].append(idx)
        ret[1] = score * -log(row[idx]) # 기존 score와 현재 선정한 값의 곱으로 score를 업데이트한다.
    return ret
```

greedy decoder는 매 반복마다 해당 순서의 최선의 값(점수가 가장 작은 값)을 찾는다. 

가장 작은 값의 인덱스를 찾고 해당 인덱스를 ret의 인덱스 순서 리스트에 추가한 뒤, 점수를 이전 점수와 현재 점수의 곱으로 업데이트한다.

<div class="page-break"></div>

##### beam decoder

k를 매개변수로 받아 몇 개의 데이터를 후보로 둘 것인지 결정한다.

```python
def beam_search_decoder(k):
  # 보기 중에서 작은 순서대로 k개의 데이터
  sequences = [[[], INITNUM]] # [[점수에 적용된 인덱스 순서], 점수] 들의 리스트. 점수의 오름차순으로 저장된다.
  # data 한 줄씩 본다
  for word in range(WORDS):
    all_candidates = []
    for cur_seq in sequences: # 처음에는 1 x LETTERS 다음부턴 전에 뽑힌 후보 3 x 현재 row LETTERS = 15
      seq, score = cur_seq # 현재 순서의 지금까지의 결과와 점수
      np.random.seed(int(score*10)) # 현재 순서의 점수로 random seed룰 준다
      row = np.random.rand(LETTERS) # LETTERS만큼 랜덤값 생성
      for j in range(LETTERS): # 생성한 랜덤값을 돌면서 후보를 넣는다
        candidate = [seq + [j], score * 10 * -log(row[j])] # 값이 더 잘 보이도록 *10
        all_candidates.append(candidate)
    ordered = sorted(all_candidates, key=lambda tup: tup[1]) # all_candidates 오름차순으로 정렬 후
    sequences = ordered[:k] # 작은 순서대로 k개만큼 선택한다
  return sequences
```

모든 후보들을 모아서 점수를 기준으로 오름차순으로 정렬한다. 이후 작은 순서대로 k개만큼 선택하는 과정을 WORDS(10) 만큼 반복한다.

-log(점수)로 계산을 하면 작은 숫자부터 큰 확률이 나온다.

첫 반복에는 초기값과 데이터들의 곱으로 5개이고, 이후부터는 k x 데이터의 개수가 전체 후보가 된다. 예를 들어 k=3일 때 all_candidates의 길이는 순서대로 [5, 15, 15, ..., 15]가 된다.

beam search에서는 후보가 k만큼 있기 때문에 greedy만큼 빠르지는 않지만, 현재 탐색의 결과가 이전 탐색의 결과를 반영하고, 더 많은 경우의 수에서 비교하기 때문에 더 높은 정확도가 나타난다.

#### 실행 결과

<img src="/Users/jiwon/Library/Application Support/typora-user-images/스크린샷 2020-05-24 오후 11.09.03.png" alt="스크린샷 2020-05-24 오후 11.09.03" style="zoom:40%;" />

greedy의 경우 각 순서마다 5개의 랜덤한 값 중 가장 낮은 값을 선택하였고, beam의 경우 5개의 랜덤한 값 중 낮은 3개의 값을 선택하였을 때의 결과이다.

초기값은 greedy와 beam 모두 같은 random seed를 사용하였기 때문에 첫 데이터는 같지만, greedy는 인덱스 0를 선택하였고, beam은 모두 인덱스 2을 선택하였다. 이는 첫 데이터 5개에서 인덱스 0의 데이터가 가장 작았지만, 이후 데이터와의 조합을 비교했을 때에는 인덱스 2의 데이터를 선택하는 것이 결과적으로 더 작다는 것을 보여준다.