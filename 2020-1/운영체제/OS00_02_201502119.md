## 201502119 정지원

#### System Call이란?

유저 모드에 있는 응용프로그램이 커널의 기능을 사용하게 하는 인터페이스이다. 즉, 커널에서 사용자에게 제공하는 함수이고, 사용자는 이를 호출하여 커널의 기능을 사용할 수 있다.

#### System Call 처리 과정

##### 사전 지식

- 시스템 콜은 "소프트웨어 인터럽트"의 한 종류이고, 이를 '**트랩(Trap)**'이라 한다.
- 시스템 콜의 기능별로 고유번호가 구분지어 있는데, 이는 **IDT(Interrupt Descriptor Table)**에 저장되고, IDT의 위치는 **IDTR**이라는 레지스터에 있다.

##### 처리 과정

![img](https://wiki.kldp.org/KoreanDoc/html/EmbeddedKernel-KLDP/images/fork-system-call.png)

>  fork(시스템 콜)의 흐름이 시각적으로 잘 나타나있는 그림이 있어 참고하였다.
>
> [출처 : https://wiki.kldp.org/KoreanDoc/html/EmbeddedKernel-KLDP/system-call-table.html](https://wiki.kldp.org/KoreanDoc/html/EmbeddedKernel-KLDP/system-call-table.html)

1. 응용프로그램에서 fork()를 호출한다.
2. C 라이브러리(libc)에서 fork()를 실행한다.
3. fork()의 시스템 호출 번호(2)를 eax 레지스터에 저장하고 $0x80을 실행하여 인터럽터 80번을 발생시킨다.
4. 커널은 IDT를 참조하여 해당 시스템콜을 처리한다.

#### 실습

다음과 같은 프로그램을 만들어 디버깅 하였다.

<img src="/Users/jiwon/Library/Application Support/typora-user-images/스크린샷 2020-05-21 오후 5.25.15.png" alt="스크린샷 2020-05-21 오후 5.25.15" style="zoom:50%;" />

fork()가 있는 line에 breakpoint를 걸고 실행해보았다.

gdb로는 시스템콜을 볼 수 없는 것 같아..서 구글링 결과 strace를 통해 시스템콜 디버깅을 할 수 있다고 한다.

<img src="/Users/jiwon/Library/Application Support/typora-user-images/스크린샷 2020-05-21 오후 5.52.07.png" alt="스크린샷 2020-05-21 오후 5.52.07" style="zoom:50%;" />

실행해 보면 로그가 많이 나오는데 fork()만 찾아보기로 했다.

<img src="/Users/jiwon/Library/Application Support/typora-user-images/스크린샷 2020-05-21 오후 5.53.32.png" alt="스크린샷 2020-05-21 오후 5.53.32" style="zoom:50%;" />

clone()을 보면 fork()가 실행된 것을 알 수 있고, 리턴값이 27976인 걸로 보아 자식 프로세스의 pid가 27976인 것으로 생각된다.

밑으로 내려가보면 parent를 출력하고 +++ exited with 0 +++ 으로 프로세스를 종료한다.

다음 아까 clone()으로 생성했던 자식 프로세스(27976)로 가서 child를 출력하고 +++ exited with 0 +++ 으로 프로세스를 종료한다.