## 201502119 정지원

#### Producer-consumer 문제

##### 변경 전

<img src="/Users/jiwon/Library/Application Support/typora-user-images/스크린샷 2020-05-21 오후 6.31.44.png" alt="스크린샷 2020-05-21 오후 6.31.44" style="zoom:50%;" />

full과 empty가 나온다.

Mutex를 이용하여 이 문제를 해결해보자.

##### 코드 수정

```c
//producer(void *arg) : 생산자 thread
void *producer(void *arg){
	int i;
	int id;
	int input;

	id = pc++;
	//생산자는 생산 횟수(6)만큼 생산을 하고 버퍼에 넣는다.
	for(i = 0; i<P_COUNT; i++){
		//버퍼에 넣을 임의의 값 생성
		input = random()%100;
		usleep(input);
		printf("producer %d add Q %d\n",id, input);

		/***********************  코드 작성 부분  *************************/
		/*  소비자가 버퍼에 접근하지 못하도록 임계영역으로 설정           */
        pthread_mutex_lock(&buffer_lock);
		/*  버퍼가 가득차면 대기(반드시 while문 사용, if문 사용하지 말 것)*/
        while(CQ_count == Q_SIZE)
            pthread_cond_wait(&buffers, &buffer_lock);
		addQ(input);	/* input을 버퍼에 넣는다                          */
		/*              버퍼 안에 item이 있음을 소비자에게 알림           */
        pthread_cond_signal(&items);
		/*  삽입이 끝나면 임계영역을 빠져 나가므로 mutex 락을 해제        */
        pthread_mutex_unlock(&buffer_lock);
		/******************************************************************/

	}
}

//consumer(void *arg) : 소비자 thread
void *consumer(void *arg){
	int i;
	int id;
	int output;
	id = cc++;

	for(i = 0; i<C_COUNT; i++){
		usleep(random()%100);

		/***********************  코드 작성 부분  *************************/
		/*  생산자가 버퍼에 접근하지 못하도록 임계영역으로 설정           */
        pthread_mutex_lock(&buffer_lock);
		/*버퍼가 비어있으면 대기(반드시 while문 사용, if문 사용하지 말 것)*/
        while(CQ_count == 0)
            pthread_cond_wait(&items, &buffer_lock);
		output=getQ();		/* item을 버퍼로부터 가져온다             */
		/*        버퍼 안에 item을 소비했다고 생산자에게 알림		  */
        pthread_cond_signal(&buffers);
		/*     소비가 끝나면 임계영역을 빠져 나가므로 mutex 락을 해제     */
        pthread_mutex_unlock(&buffer_lock);
		/******************************************************************/

		if(output != -1)
			printf("consumer %d get Q %d\n",id, output);
	}
}

```

생산자 코드와 소비자 코드를 위와 같이 수정하였다.

1. 생산자와 소비자 둘 다 큐에 접근하기 전, mutex를 lock한다. 
2. 생산자의 경우 버퍼가 가득차면 소비자의 경우 버퍼가 비어있으면 버퍼에 item이 빠지기를 기다려야 하고, 소비자의 경우 item이 들어오기를 기다려야 하는데 이 때 while문을 사용하여 구현한다.
   1. while문 안에는 pthread_cond_wait 함수를 통해 각 조건변수에 시그널이 오기를 기다린다.
3. while문을 통과하면 조건이 성립한 것이므로 버퍼에 item을 넣거나 뺀다.
4. pthread_cond_signal 함수를 통해 상대방에게(상대방의 조건변수) 시그널을 보낸다.
5. 생산/소비가 끝나면 mutex를 unlock한다.



##### 실행 결과

<img src="/Users/jiwon/Library/Application Support/typora-user-images/스크린샷 2020-05-21 오후 9.23.45.png" alt="스크린샷 2020-05-21 오후 9.23.45" style="zoom:60%;" />

full과 empty가 실행되지 않는다.